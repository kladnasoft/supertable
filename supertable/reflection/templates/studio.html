{% extends "base.html" %}

{% block title %}Studio{% endblock %}

{% block head_extra %}
<style>
  :root { --azure: #1c96ca; }
  .muted { color:#64748b; font-size: 12px; }
  .mono {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  .nb-root {
    background: #ffffff;
    border-radius: 16px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    padding: 24px 28px;
    border: 1px solid rgba(0,0,0,0.05);
    border-left: 5px solid #1c96ca;
  }

  .nb-topbar {
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap: 12px;
    flex-wrap: wrap;
  }

  .nb-title {
    font-size: 18px;
    font-weight: 900;
    color:#0f172a;
  }

  /* Vault/Compute-style tab bar (matches vault.html / compute.html) */
  #tab-navigation {
    display: flex;
    align-items: center;
    gap: 24px;
    border-bottom: 1px solid rgba(15, 23, 42, 0.12);
    padding: 0 2px;
    flex-wrap: wrap;
  }

  .tab {
    padding: 8px 0;
    margin-bottom: -1px;
    border: none;
    border-bottom: 2px solid transparent;
    background: transparent;
    cursor: pointer;
    font-size: 13px;
    color: #0f172a;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    user-select: none;
  }

  .tab i { font-size: 13px; color: inherit; }

  .tab.active {
    color: var(--azure, #1c96ca);
    border-bottom-color: var(--azure, #1c96ca);
    font-weight: 500;
  }

  .tab-sep {
    width: 1px;
    height: 22px;
    margin: 0 10px;
    background: rgba(15, 23, 42, 0.12);
    user-select: none;
  }

.tab-add {
    min-width: 22px;
    height: 22px;
    border-radius: 999px;
    border: 1px solid #cbd5e1;
    background: #f8fafc;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    cursor: pointer;
    color: #0f172a;
    padding: 0;
    margin-bottom: 4px;
  }
  .tab-add:hover { background: #e2e8f0; }

  .tab-close {
    width: 18px;
    height: 18px;
    border-radius: 999px;
    border: 1px solid rgba(148,163,184,.8);
    background: #fff;
    display: inline-flex;
    align-items:center;
    justify-content:center;
    font-size: 11px;
    color: #64748b;
    cursor:pointer;
    padding: 0;
  }
  .tab-close:hover {
    background: rgba(239,68,68,0.12);
    border-color: rgba(239,68,68,0.55);
    color: rgba(239,68,68,0.9);
  }

  .tab-doc {
    display:inline-flex;
    align-items:center;
    gap: 8px;
  }

  .hidden { display:none; }

  .panel {
    border: 1px solid rgba(15,23,42,.10);
    border-radius: 16px;
    background: #fff;
    padding: 14px 14px;
  }

  .panel-inset {
    background: rgba(248,250,252,.65);
    border-color: rgba(15,23,42,.08);
  }

  .panel + .panel { margin-top: 12px; }

  .panel-head {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    flex-wrap: wrap;
  }

  .panel-title {
    font-weight: 900;
    color:#0f172a;
    display:flex;
    align-items:center;
    gap: 8px;
    font-size: 13px;
  }

  /* Buttons match admin style */
  .btn-azure-outline {
    border: 1px solid #1c96ca;
    background: transparent;
    color: #1c96ca;
    font-weight: 600;
    transition: background-color 0.2s ease, color 0.2s ease;
  }
  .btn-azure-outline:hover { background: #1c96ca; color: #ffffff; }

  .btn-danger-outline {
    border: 1px solid rgba(239,68,68,0.75);
    background: transparent;
    color: rgba(239,68,68,0.9);
    font-weight: 700;
    transition: background-color 0.2s ease, color 0.2s ease;
  }
  .btn-danger-outline:hover { background: rgba(239,68,68,0.9); color:#fff; }

  /* Notebook list */
  .toolbar {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 10px;
  }

  .searchbox {
    display:flex;
    align-items:center;
    gap: 8px;
    flex-wrap: wrap;
  }
  .searchbox input { min-width: 320px; }
  @media (max-width: 680px) { .searchbox input { min-width: 100%; } }

  /* Editor */
  .editor-top {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 12px;
  }
  .editor-top .left,
  .editor-top .right {
    display:flex;
    align-items:center;
    gap: 10px;
    flex-wrap: wrap;
  }

  .editor-subbar {
    display:flex;
    align-items:center;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 10px;
  }

  .nb-name-input {
    min-width: 260px;
    font-weight: 700;
  }

  /* Cells */
  .cell {
    border: 1px solid rgba(15,23,42,.10);
    border-radius: 16px;
    background: #fff;
    overflow: hidden;
    margin-top: 12px;
  }

  .cell-head {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    padding: 10px 12px;
    background: rgba(248,250,252,.9);
    border-bottom: 1px solid rgba(15,23,42,.08);
  }

  .cell-left {
    display:flex;
    align-items:center;
    gap: 10px;
    font-weight: 900;
    color:#334155;
    font-size: 12px;
  }

  .cell-actions {
    display:flex;
    align-items:center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .cell-body { padding: 10px 12px; }

  .codebox {
    width: 100%;
    min-height: 130px;
    resize: vertical;
    border-radius: 14px;
    border: 1px solid rgba(15,23,42,.14);
    padding: 12px 12px;
    background: #ffffff;
    font-size: 13px;
    line-height: 1.35;
  }

  .output {
    margin-top: 10px;
    border-radius: 14px;
    border: 1px solid rgba(15,23,42,.10);
    background: rgba(248,250,252,.9);
    padding: 10px 12px;
    font-size: 12px;
    color:#0f172a;
    display:none;
  }
  .output.err { border-left: 4px solid rgba(239,68,68,0.7); }
  .output.ok { border-left: 4px solid rgba(16,185,129,0.7); }
  .output pre { margin:0; white-space: pre-wrap; }

  .md-preview {
    margin-top: 10px;
    border-radius: 14px;
    border: 1px solid rgba(15,23,42,.10);
    background: rgba(255,255,255,.92);
    padding: 10px 12px;
    font-size: 13px;
    color:#0f172a;
    display:none;
  }
  .md-preview h1, .md-preview h2, .md-preview h3 { margin: 0 0 8px 0; }
  .md-preview p { margin: 0 0 8px 0; }
  .md-preview code { background: rgba(15,23,42,.06); padding: 1px 4px; border-radius: 6px; }
  .md-preview pre { background: rgba(15,23,42,.06); padding: 10px; border-radius: 12px; overflow:auto; }


  /* Tiny toast */
  .toast {
    position: fixed;
    right: 18px;
    top: 16px;
    z-index: 5000;
    background: rgba(15,23,42,0.92);
    color: #fff;
    border-radius: 14px;
    padding: 10px 12px;
    font-size: 12px;
    box-shadow: 0 18px 40px rgba(0,0,0,0.22);
    display:none;
    max-width: min(520px, calc(100vw - 36px));
  }

  /* Modal */
  .nb-modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.55);
    display:none;
    align-items:center;
    justify-content:center;
    padding: 18px;
    z-index: 4000;
  }
  .nb-modal .card {
    background:#fff;
    border-radius: 16px;
    box-shadow: 0 30px 80px rgba(0,0,0,0.25);
    border: 1px solid rgba(0,0,0,0.08);
    max-width: 980px;
    width: 100%;
    padding: 14px;
  }
  .nb-modal .head {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
  }
  .nb-modal .title {
    font-weight: 900;
    color:#0f172a;
    font-size: 14px;
    display:flex;
    align-items:center;
    gap: 8px;
  }
  .nb-modal .body { margin-top: 10px; }
  .nb-modal .actions {
    margin-top: 12px;
    display:flex;
    justify-content:flex-end;
    gap: 10px;
    flex-wrap: wrap;
  }

  /* Snippets list */
  .sn-grid {
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 12px;
  }
  @media (max-width: 980px) { .sn-grid { grid-template-columns: 1fr; } }

  .sn-card {
    border: 1px solid rgba(15,23,42,.10);
    border-radius: 16px;
    padding: 12px 12px;
    background:#fff;
  }
  .sn-card .top {
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap: 10px;
  }
  .sn-card .name { font-weight: 900; color:#0f172a; font-size: 13px; }
  .sn-card pre {
    margin: 10px 0 0 0;
    padding: 10px 10px;
    border-radius: 14px;
    background: rgba(248,250,252,.9);
    border: 1px solid rgba(15,23,42,.10);
    font-size: 12px;
    white-space: pre-wrap;
  }
  .sn-actions {
    display:flex;
    align-items:center;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 10px;
  }
</style>
{% endblock %}

{% block content %}

{% include "selection.html" %}

<div style="height: 18px;"></div>


<div id="tab-navigation" style="margin: 0 6px 14px 6px;">
  <button id="tab-list" type="button" class="tab active" data-pane="list" onclick="switchTab('list')" aria-selected="true">
    <i class="fas fa-list"></i><span>Studio</span>
  </button>

  <div class="tab-sep" aria-hidden="true"></div>

  <button id="tab-snippets" type="button" class="tab" data-pane="snippets" onclick="switchTab('snippets')" aria-selected="false">
    <i class="fas fa-wand-magic-sparkles"></i><span>Snippets</span>
  </button>

  <div class="tab-sep" aria-hidden="true"></div>

  <button type="button" class="tab-add" id="btnNewNotebook" title="New lab">+</button>

  <div id="openTabs" style="display:flex; gap:24px; align-items:center; flex-wrap:wrap;"></div>
</div>

<div style="height: 10px;"></div>

<div id="nbRoot"
     class="nb-root"
     data-org="{{ sel_org }}"
     data-sup="{{ sel_sup }}"
     data-user-hash="{{ session_user_hash }}"
     data-user-name="{{ session_username }}"
>
  <div class="nb-topbar">
    <div>
      <div class="nb-title">Studio</div>
      <div class="muted" style="margin-top:4px;">
        Manage lab workspaces and snippets. Open sessions in editor tabs (Synapse-style).
      </div>
    </div>
  </div>



  {% if not has_tenant %}
    <div style="margin-top: 14px; color:#64748b;">Select a tenant (organization + super) first.</div>
  {% else %}
    <!-- Notebooks list pane -->
    <div id="pane-list" style="margin-top:14px;">
      <div class="panel">
        <div class="panel-head">
          <div class="panel-title"><i class="fas fa-flask" style="color:#1c96ca;"></i> Studio</div>
          <div class="muted">Stored locally for now. Creator = your username.</div>
        </div>

        <div class="toolbar">
          <div class="searchbox">
            <i class="fas fa-magnifying-glass" style="color:#94a3b8;"></i>
            <input class="form-control form-control-sm" id="nbSearch" placeholder="Search labs by name / creator..." />
          </div>

          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <button type="button" class="btn btn-sm btn-azure-outline" id="btnRefreshList">
              <i class="fas fa-rotate"></i> Refresh
            </button>
          </div>
        </div>

        <div style="height:10px;"></div>

        <div class="table-responsive">
          <table class="table table-sm" style="margin-bottom:0;">
            <thead>
              <tr>
                <th style="min-width:240px;">Name</th>
                <th style="min-width:180px;">Creator</th>
                <th style="min-width:190px;">Created</th>
                <th style="min-width:190px;">Updated</th>
                <th style="min-width:240px;">Actions</th>
              </tr>
            </thead>
            <tbody id="nbListBody"></tbody>
          </table>
        </div>

        <div id="nbEmpty" class="muted" style="margin-top:12px; display:none;">
          No labs yet. Click <b>+</b> to create one.
        </div>
      </div>
    </div>

    <!-- Snippets pane -->
    <div id="pane-snippets" class="hidden" style="margin-top:14px;">
      <div class="panel">
        <div class="panel-head">
          <div class="panel-title"><i class="fas fa-wand-magic-sparkles" style="color:#1c96ca;"></i> Snippets</div>
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <button type="button" class="btn btn-sm btn-azure-outline" id="btnNewSnippet">
              <i class="fas fa-plus"></i> New snippet
            </button>
          </div>
        </div>

        <div class="toolbar">
          <div class="searchbox">
            <i class="fas fa-magnifying-glass" style="color:#94a3b8;"></i>
            <input class="form-control form-control-sm" id="snSearch" placeholder="Search snippets by name or content..." />
          </div>
        </div>

        <div id="snGrid" class="sn-grid"></div>

        <div id="snEmpty" class="muted" style="margin-top:12px; display:none;">
          No snippets yet. Click <b>New snippet</b> to create one.
        </div>
      </div>
    </div>

    <!-- Editor pane (shown when an editor tab is active) -->
    <div id="pane-editor" class="hidden" style="margin-top:14px;">
      <div class="panel">
        <div class="panel-head">
          <div class="panel-title"><i class="fas fa-code" style="color:#1c96ca;"></i> Studio editor</div>
          <div class="muted" id="editorStatus"></div>
        </div>

        <!-- Row 1: Run all / Stop -->
        <div class="editor-top">
          <div class="left">
            <input class="form-control form-control-sm nb-name-input" id="nbEditorName" placeholder="Untitled lab" />
            <span class="muted" id="nbEditorMeta"></span>
          </div>
          <div class="right">
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
              <span class="muted" style="font-weight:900;">Compute</span>
              <select class="form-select form-select-sm mono" id="computeSelect" style="min-width:220px;">
                <option value="">Loadingâ€¦</option>
              </select>
              <button type="button" class="btn btn-sm btn-azure-outline" id="btnRefreshCompute" title="Refresh compute pools">
                <i class="fas fa-rotate"></i>
              </button>
            </div>
            <button type="button" class="btn btn-sm btn-azure-outline" id="btnRunAll">
              <i class="fas fa-play"></i> Run All
            </button>
            <button type="button" class="btn btn-sm btn-danger-outline" id="btnStop">
              <i class="fas fa-stop"></i> Stop
            </button>
            <button type="button" class="btn btn-sm btn-azure-outline" id="btnSaveNotebook">
              <i class="fas fa-save"></i> Save
            </button>
                        <button type="button" class="btn btn-sm btn-azure-outline" id="btnDownloadNotebook">
              <i class="fas fa-download"></i> Download
            </button>
<button type="button" class="btn btn-sm btn-danger-outline" id="btnCloseTab" style="display:none;">
              <i class="fas fa-xmark"></i> Close
            </button>
          </div>
        </div>

        <!-- Cells -->
        <div class="panel panel-inset" style="padding:12px; margin-top:12px;">
          <div class="panel-title" style="font-size:12px; margin-bottom:8px;">
            <i class="fas fa-table-cells" style="color:var(--azure, #1c96ca);"></i> Cells
          </div>

          <div class="editor-subbar" style="margin-top:0;">
            <button type="button" class="btn btn-sm btn-azure-outline" id="btnAddCellTop" title="Add cell">
              <i class="fas fa-plus"></i>
            </button>
            <button type="button" class="btn btn-sm btn-danger-outline" id="btnDeleteActiveCell" title="Delete active cell">
              <i class="fas fa-trash"></i>
            </button>
            <button type="button" class="btn btn-sm btn-azure-outline" id="btnRunActive" title="Run active cell">
              <i class="fas fa-play"></i>
            </button>
            <button type="button" class="btn btn-sm btn-azure-outline" id="btnSnippetPicker" title="Search snippets">
              <i class="fas fa-magnifying-glass"></i> Snippets
            </button>

                        <button type="button" class="btn btn-sm btn-azure-outline" id="btnVaultPicker" title="Search vault envs">
              <i class="fas fa-lock"></i> Vault
            </button>
            <button type="button" class="btn btn-sm btn-azure-outline" id="btnConnectorPicker" title="Search Airbyte connectors">
              <i class="fas fa-plug"></i> Connectors
            </button>
<div style="flex:1;"></div>
          </div>

          <div id="cells"></div>
        </div>
      </div>
    </div>
  {% endif %}
</div>

<div class="toast" id="nbToast"></div>

<!-- Modal -->
<div class="nb-modal" id="nbModal">
  <div class="card">
    <div class="head">
      <div class="title" id="nbModalTitle"><i class="fas fa-pen"></i> Modal</div>
      <button type="button" class="btn btn-sm btn-danger-outline" id="nbModalClose"><i class="fas fa-xmark"></i></button>
    </div>
    <div class="body" id="nbModalBody"></div>
    <div class="actions">
      <button type="button" class="btn btn-sm btn-azure-outline" id="nbModalConfirm"><i class="fas fa-check"></i> Save</button>
    </div>
  </div>
</div>

{% endblock %}

{% block body_scripts %}
<script>
(function () {
  const ln = document.getElementById("link-studio");
  if (ln) ln.classList.add("active");

  function root() { return document.getElementById("nbRoot"); }
  function enc(v) { return encodeURIComponent(v || ""); }
  function cssEsc(v) {
    try { return (window.CSS && CSS.escape) ? CSS.escape(String(v)) : String(v).replace(/[^a-zA-Z0-9_-]/g, '\\$&'); }
    catch (e) { return String(v || ""); }
  }
  function nowISO() { return new Date().toISOString(); }
  function fmt(ts) {
    try { return new Date(ts).toLocaleString(); } catch (e) { return String(ts || ""); }
  }

  function currentCtx() {
    const el = root();
    return {
      org: el ? (el.dataset.org || "") : "",
      sup: el ? (el.dataset.sup || "") : "",
      userHash: el ? (el.dataset.userHash || "") : "",
      userName: el ? (el.dataset.userName || "") : "",
    };
  }

  function displayCreator(val) {
    const { userHash, userName } = currentCtx();
    const v = String(val || '');
    // Stored docs are per-user-hash; show username for legacy hash values.
    if (userName && (v === userHash || !v || /^[0-9a-f]{12,}$/i.test(v))) return userName;
    return v;
  }


  function escapeHtml(str) {
    return String(str || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function escapeHtmlNl(str) {
    // Escape HTML and render newlines like a console (index.html-style).
    return escapeHtml(String(str || '')).replace(/\n/g, '<br>');
  }

  function toast(msg) {
    const el = document.getElementById('nbToast');
    if (!el) return;
    el.textContent = String(msg || '');
    el.style.display = 'block';
    clearTimeout(toast._t);
    toast._t = setTimeout(() => { el.style.display = 'none'; }, 1800);
  }

  async function postJSON(url, obj, signal) {
    const resp = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(obj || {}),
      credentials: "same-origin",
      signal,
    });
    const text = await resp.text();
    let js = null;
    try { js = JSON.parse(text); } catch (e) { js = null; }
    if (!resp.ok) {
      const msg = (js && (js.detail || js.error)) || text || ("Request failed: " + resp.status);
      throw new Error(msg);
    }
    return js;
  }

  async function getJSON(url, signal) {
    const resp = await fetch(url, { credentials: "same-origin", signal });
    const text = await resp.text();
    let js = null;
    try { js = JSON.parse(text); } catch (e) { js = null; }
    if (!resp.ok) {
      const msg = (js && (js.detail || js.error)) || text || ("Request failed: " + resp.status);
      throw new Error(msg);
    }
    return js;
  }

  function k(prefix) {
    const { org, sup, userHash } = currentCtx();
    return `nb:${org}:${sup}:${userHash}:${prefix}`;
  }

  function lsGet(key, fallback) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      return JSON.parse(raw);
    } catch (e) {
      return fallback;
    }
  }
  function lsSet(key, value) {
    try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) {}
  }

  function genId(prefix) {
    const rnd = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (String(Math.random()).slice(2) + Date.now());
    return `${prefix}_${rnd}`;
  }

  function normalizeCell(c) {
    const obj = c || {};
    const out = obj.output || null;
    const hasOut = out && (String(out.stdout||'').trim() || String(out.stderr||'').trim() || String(out.meta||'').trim());
    return {
      id: obj.id ? String(obj.id) : genId('c'),
      type: (obj.type === 'markdown') ? 'markdown' : 'code',
      code: (typeof obj.code === 'string') ? obj.code : String(obj.code || ''),
      output: hasOut ? { ok: !!out.ok, stdout: String(out.stdout||''), stderr: String(out.stderr||''), meta: String(out.meta||'') } : null,
    };
  }


  // -----------------------------
  // Storage models
  // -----------------------------
  function loadNotebooks() {
    let arr = lsGet(k('notebooks'), null);
    if (!Array.isArray(arr)) arr = [];
    return arr;
  }
  function saveNotebooks(arr) { lsSet(k('notebooks'), arr || []); }

  function loadSnippets() {
    let arr = lsGet(k('snippets'), null);
    if (!Array.isArray(arr) || !arr.length) {
      arr = [
        { id:'s_hello', name:'Hello world', code:"print('Hello from SuperTable Studio ðŸš€')", created_at: nowISO(), updated_at: nowISO() },
        { id:'s_read', name:'Read from table', code:"# returns: (df, status, message)\nres = st_read_table('table_1', limit=10)\nres[0].head()", created_at: nowISO(), updated_at: nowISO() },
        { id:'s_sql', name:'SQL query', code:"q = \"\"\"select * from table_1 limit 5\"\"\"\nst_sql(q)[0]", created_at: nowISO(), updated_at: nowISO() },
      ];
      lsSet(k('snippets'), arr);
    }
    return arr;
  }
  function saveSnippets(arr) { lsSet(k('snippets'), arr || []); }

  function kernelSessionKey(scopeId) { return k(`kernel_session:${scopeId}`); }
  function getOrCreateKernelSessionId(scopeId) {
    const kk = kernelSessionKey(scopeId);
    let v = String(lsGet(kk, '') || '');
    if (!v) {
      v = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random()).slice(2);
      lsSet(kk, v);
    }
    return v;
  }

  function computePoolKey() { return k('compute_pool'); }
  function getSavedComputePoolId() { return String(lsGet(computePoolKey(), '') || ''); }
  function setSavedComputePoolId(v) { lsSet(computePoolKey(), String(v || '')); }

  function computePoolLabel(p) {
    const name = String((p && p.name) ? p.name : 'Pool').trim() || 'Pool';
    const kind = String((p && p.kind) ? p.kind : '').trim();
    const size = String((p && p.size) ? p.size : '').trim();
    const extra = (kind || size) ? ` (${kind || '?'} / ${size || '?'})` : '';
    return name + extra;
  }

  function getSelectedComputePool() {
    const id = String(selectedComputePoolId || '').trim();
    if (!id) return null;
    return (computePools || []).find(p => String((p && p.id) ? p.id : '') === id) || null;
  }

  function renderComputeSelect() {
    const sel = document.getElementById('computeSelect');
    if (!sel) return;

    sel.innerHTML = '';
    const items = Array.isArray(computePools) ? computePools.slice() : [];

    if (!items.length) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'No pools';
      sel.appendChild(opt);
      sel.disabled = true;
      return;
    }

    // default first
    items.sort((a, b) => (b && b.is_default ? 1 : 0) - (a && a.is_default ? 1 : 0));

    items.forEach(p => {
      const opt = document.createElement('option');
      opt.value = String((p && p.id) ? p.id : '');
      opt.textContent = computePoolLabel(p) + ((p && p.is_default) ? ' (default)' : '');
      sel.appendChild(opt);
    });

    sel.disabled = false;
    const want = String(selectedComputePoolId || '').trim();
    if (want) sel.value = want;
  }

  async function loadComputePools() {
    const sel = document.getElementById('computeSelect');
    if (sel) {
      sel.disabled = true;
      sel.innerHTML = '<option value="">Loadingâ€¦</option>';
    }

    const { org, sup } = currentCtx();
    if (!org || !sup) {
      computePools = [];
      selectedComputePoolId = '';
      renderComputeSelect();
      return;
    }

    try {
      const js = await getJSON(`/reflection/compute/list?org=${enc(org)}&sup=${enc(sup)}`);
      computePools = (js && js.data && Array.isArray(js.data.items)) ? js.data.items : [];
    } catch (e) {
      computePools = [];
    }

    const saved = getSavedComputePoolId();
    const hasSaved = saved && (computePools || []).some(p => String((p && p.id) ? p.id : '') === saved);
    const def = (computePools || []).find(p => p && p.is_default) || (computePools[0] || null);
    selectedComputePoolId = hasSaved ? String(saved) : (def ? String(def.id || '') : '');
    if (selectedComputePoolId) setSavedComputePoolId(selectedComputePoolId);

    renderComputeSelect();
  }

  function selectComputePool(idRaw) {
    const id = String(idRaw || '').trim();
    if (!id) return;
    const ok = (computePools || []).some(p => String((p && p.id) ? p.id : '') === id);
    if (!ok) return;
    selectedComputePoolId = id;
    setSavedComputePoolId(id);
    // Switching compute invalidates any existing notebook WS session.
    try { closeAllNotebookWsSessions('compute changed'); } catch (e) {}
  }

  // -----------------------------
  // UI state
  // -----------------------------
  let notebooks = [];
  let snippets = [];
  let openDocs = []; // editor tabs: { tab_id, notebook_id|null, name, cells, creator, created_at, updated_at, dirty }
  let activePane = "list"; // list | snippets | editor
  let activeTabId = ""; // for editor tabs
  let activeCellId = "";

  // run control
  let stopRequested = false;
  let activeControllers = [];
  let activeSockets = [];

  // notebook ws sessions (per editor tab; preserves kernel state like index.html)
  let notebookWsSessions = {};

  // compute pools
  let computePools = [];
  let selectedComputePoolId = '';

  function setPane(pane) {
    activePane = pane;
    const listEl = document.getElementById('pane-list');
    const snEl = document.getElementById('pane-snippets');
    const edEl = document.getElementById('pane-editor');

    if (listEl) listEl.classList.toggle('hidden', pane !== 'list');
    if (snEl) snEl.classList.toggle('hidden', pane !== 'snippets');
    if (edEl) edEl.classList.toggle('hidden', pane !== 'editor');

    // highlight base tabs only when in those panes
    document.querySelectorAll('#tab-navigation .tab[data-pane]').forEach(t => {
      const p = t.getAttribute('data-pane');
      const isActive = (p === pane);
      t.classList.toggle('active', isActive);
      t.setAttribute('aria-selected', isActive ? 'true' : 'false');
    });
    if (pane === 'editor') {
      // base tabs not active
      document.querySelectorAll('#tab-navigation .tab[data-pane]').forEach(t => t.classList.remove('active'));
    }
  }

  window.switchTab = function (name) {
    setPane(String(name || ''));
  };

  function renderOpenTabs() {
    const wrap = document.getElementById('openTabs');
    if (!wrap) return;
    wrap.innerHTML = '';

    openDocs.forEach(doc => {
      const box = document.createElement('div');
      box.className = 'tab-doc';

      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'tab' + (doc.tab_id === activeTabId ? ' active' : '');
      const dot = doc.dirty ? ' â€¢' : '';
      btn.innerHTML = `<i class="fas fa-book"></i><span>${escapeHtml(doc.name || 'Untitled')}${dot}</span>`;
      btn.addEventListener('click', () => activateEditorTab(doc.tab_id));

      const close = document.createElement('button');
      close.type = 'button';
      close.className = 'tab-close';
      close.title = 'Close';
      close.innerHTML = '<i class="fas fa-xmark"></i>';
      close.addEventListener('click', (e) => {
        e.stopPropagation();
        closeEditorTab(doc.tab_id);
      });

      box.appendChild(btn);
      box.appendChild(close);
      wrap.appendChild(box);
    });
  }

  function renderNotebookList() {
    const body = document.getElementById('nbListBody');
    const empty = document.getElementById('nbEmpty');
    if (!body) return;

    const q = String((document.getElementById('nbSearch') || {}).value || '').trim().toLowerCase();
    const rows = notebooks.filter(n => {
      const hay = `${n.name||''} ${n.creator||''}`.toLowerCase();
      return !q || hay.includes(q);
    });

    body.innerHTML = '';
    rows.forEach(n => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><b>${escapeHtml(n.name || 'Untitled')}</b></td>
        <td class="mono">${escapeHtml(displayCreator(n.creator || ''))}</td>
        <td>${escapeHtml(fmt(n.created_at))}</td>
        <td>${escapeHtml(fmt(n.updated_at || n.created_at))}</td>
        <td>
          <button type="button" class="btn btn-sm btn-azure-outline" data-act="open"><i class="fas fa-up-right-from-square"></i> Open</button>
          <button type="button" class="btn btn-sm btn-azure-outline" data-act="download"><i class="fas fa-download"></i> Download</button>
          <button type="button" class="btn btn-sm btn-danger-outline" data-act="delete"><i class="fas fa-trash"></i> Delete</button>
        </td>
      `;
      tr.querySelector('button[data-act="open"]').addEventListener('click', () => openNotebookInTab(n.id));
      tr.querySelector('button[data-act="download"]').addEventListener('click', () => downloadNotebookIpynb(n));
      tr.querySelector('button[data-act="delete"]').addEventListener('click', () => deleteNotebook(n.id));
      body.appendChild(tr);
    });

    if (empty) empty.style.display = rows.length ? 'none' : '';
  }

  function deleteNotebook(id) {
    const nb = notebooks.find(x => x.id === id);
    const name = nb ? nb.name : 'this lab';
    if (!confirm(`Delete ${name}?`)) return;

    notebooks = notebooks.filter(x => x.id !== id);
    saveNotebooks(notebooks);

    // also close any open tabs for it
    const toClose = openDocs.filter(d => d.notebook_id === id).map(d => d.tab_id);
    toClose.forEach(tid => closeEditorTab(tid, { skipConfirm: true }));

    renderNotebookList();
    toast('Studio deleted');
  }

  function openNotebookInTab(id) {
    const nb = notebooks.find(x => x.id === id);
    if (!nb) return;

    const existing = openDocs.find(d => d.notebook_id === id);
    if (existing) {
      activateEditorTab(existing.tab_id);
      return;
    }

    const tab = {
      tab_id: genId('tab'),
      notebook_id: nb.id,
      name: nb.name || 'Untitled',
      cells: Array.isArray(nb.cells) && nb.cells.length ? nb.cells.map(normalizeCell) : [normalizeCell({})],
      creator: nb.creator || '',
      created_at: nb.created_at,
      updated_at: nb.updated_at || nb.created_at,
      dirty: false,
    };
    openDocs.push(tab);
    activateEditorTab(tab.tab_id);
    renderOpenTabs();
  }

  function activateEditorTab(tabId) {
    const doc = openDocs.find(d => d.tab_id === tabId);
    if (!doc) return;

    activeTabId = tabId;
    activeCellId = (doc.cells && doc.cells[0]) ? doc.cells[0].id : '';

    // show editor and populate fields
    const name = document.getElementById('nbEditorName');
    const meta = document.getElementById('nbEditorMeta');
    if (name) name.value = doc.name || '';
    if (meta) {
      const who = doc.creator ? displayCreator(doc.creator) : '';
      meta.textContent = `creator: ${who} â€¢ created: ${fmt(doc.created_at)}${doc.notebook_id ? '' : ' â€¢ (unsaved)'}`;
    }

    setPane('editor');
    renderOpenTabs();
    renderCells();
  }

  function closeEditorTab(tabId, opts) {
    const o = opts || {};
    const doc = openDocs.find(d => d.tab_id === tabId);
    if (!doc) return;

    if (!o.skipConfirm && doc.dirty) {
      if (!confirm('This lab has unsaved changes. Close anyway?')) return;
    }

    try { closeNotebookWsSession(tabId, 'tab closed'); } catch (e) {}

    openDocs = openDocs.filter(d => d.tab_id !== tabId);

    if (activeTabId === tabId) {
      activeTabId = openDocs.length ? openDocs[openDocs.length - 1].tab_id : '';
      if (activeTabId) activateEditorTab(activeTabId);
      else setPane('list');
    }

    renderOpenTabs();
    toast('Tab closed');
  }

  function createNewNotebookTab() {
    const { userHash, userName } = currentCtx();
    const tab = {
      tab_id: genId('tab'),
      notebook_id: null,
      name: `Untitled ${openDocs.length + 1}`,
      cells: [normalizeCell({ code: "print('Ready. Add a cell or insert a snippet â†’')" })],
      creator: userName || userHash || '',
      created_at: nowISO(),
      updated_at: nowISO(),
      dirty: true,
    };
    openDocs.push(tab);
    activateEditorTab(tab.tab_id);
    renderOpenTabs();
    toast('New lab tab opened');
  }

  function getActiveDoc() {
    return openDocs.find(d => d.tab_id === activeTabId) || null;
  }

  // -----------------------------
  // Editor: cells
  // -----------------------------
  function createCellEl(cell, idx) {
    const el = document.createElement('div');
    el.className = 'cell';
    el.dataset.id = cell.id;

    el.innerHTML = `
      <div class="cell-head">
        <div class="cell-left">
          <span class="mono">In [${idx + 1}]</span>
          <span class="muted" id="kind-${escapeHtml(cell.id)}" style="margin-left:8px;">${cell.type === 'markdown' ? 'Markdown' : 'Code'}</span>
          <span class="muted" id="status-${escapeHtml(cell.id)}"></span>
        </div>
        <div class="cell-actions">
          <button type="button" class="btn btn-sm btn-azure-outline" data-action="run"><i class="fas fa-play"></i> ${cell.type === 'markdown' ? 'Render' : 'Run'}</button>
          <button type="button" class="btn btn-sm btn-azure-outline" data-action="toggle-type" title="Toggle markdown/code">${cell.type === 'markdown' ? 'Code' : 'MD'}</button>
          <button type="button" class="btn btn-sm btn-azure-outline" data-action="clear-output" title="Clear output"><i class="fas fa-eraser"></i></button>
          <button type="button" class="btn btn-sm btn-azure-outline" data-action="add-below" title="Add cell below"><i class="fas fa-plus"></i></button>
          <button type="button" class="btn btn-sm btn-danger-outline" data-action="delete" title="Delete cell"><i class="fas fa-trash"></i></button>
        </div>
      </div>
      <div class="cell-body">
        <textarea class="codebox mono" spellcheck="false"></textarea>
        <div class="md-preview" id="md-${escapeHtml(cell.id)}"></div>
        <div class="output mono" id="out-${escapeHtml(cell.id)}"></div>
      </div>
    `;

    const ta = el.querySelector('textarea');
    if (ta) {
      ta.value = cell.code || '';
      ta.addEventListener('focus', () => { activeCellId = cell.id; });
      ta.addEventListener('input', () => {
        const doc = getActiveDoc();
        if (!doc) return;
        const found = doc.cells.find(c => c.id === cell.id);
        if (found) {
          found.code = ta.value;
          if (found.type === 'markdown') renderMarkdownInto(cell.id, found.code);
        }
        markDirty(doc);
      });
      ta.addEventListener('keydown', async (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          e.preventDefault();
          await runCell(cell.id);
        }
      });
    }

    el.addEventListener('click', () => { activeCellId = cell.id; });

    el.querySelectorAll('button[data-action]').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.preventDefault();
        const action = btn.getAttribute('data-action');
        if (action === 'run') await runCell(cell.id);
        if (action === 'toggle-type') toggleCellType(cell.id);
        if (action === 'clear-output') clearCellOutput(cell.id);
        if (action === 'add-below') addCellBelow(cell.id);
        if (action === 'delete') deleteCell(cell.id);
      });
    });

    // apply current state
    syncCellTypeDom(cell.id);
    if (cell.type === 'markdown') renderMarkdownInto(cell.id, cell.code || '');
    if (cell.output) setOutput(cell.id, !!cell.output.ok, cell.output.stdout || '', cell.output.stderr || '', cell.output.meta || '', false);

    return el;
  }

  function syncCellTypeDom(cellId) {
    const doc = getActiveDoc();
    const cell = doc ? doc.cells.find(c => c.id === cellId) : null;
    const typ = (cell && cell.type === 'markdown') ? 'markdown' : 'code';
    const kind = document.getElementById(`kind-${cellId}`);
    if (kind) kind.textContent = (typ === 'markdown') ? 'Markdown' : 'Code';
    const cellWrap = document.querySelector(`.cell[data-id="${cssEsc(cellId)}"]`);
    if (!cellWrap) return;
    const runBtn = cellWrap.querySelector('button[data-action="run"]');
    if (runBtn) runBtn.innerHTML = `<i class="fas fa-play"></i> ${typ === 'markdown' ? 'Render' : 'Run'}`;
    const toggleBtn = cellWrap.querySelector('button[data-action="toggle-type"]');
    if (toggleBtn) toggleBtn.textContent = (typ === 'markdown') ? 'Code' : 'MD';
    const md = document.getElementById(`md-${cellId}`);
    const out = document.getElementById(`out-${cellId}`);
    if (md) md.style.display = (typ === 'markdown') ? '' : 'none';
    if (out) {
      if (typ === 'markdown') out.style.display = 'none';
      // for code cells, setOutput controls display
    }
  }

  function clearCellOutput(cellId) {
    const doc = getActiveDoc();
    if (doc) {
      const cell = doc.cells.find(c => c.id === cellId);
      if (cell) { cell.output = null; markDirty(doc); }
    }
    const out = document.getElementById(`out-${cellId}`);
    if (out) { out.innerHTML = ''; out.style.display = 'none'; }
  }

  function renderMarkdownSafe(raw) {
    const src = String(raw || '');
    const parts = [];
    const reFence = /```([\s\S]*?)```/g;
    let last = 0;
    let m;
    while ((m = reFence.exec(src)) !== null) {
      if (m.index > last) parts.push({ t: 'text', v: src.slice(last, m.index) });
      parts.push({ t: 'code', v: m[1] });
      last = m.index + m[0].length;
    }
    if (last < src.length) parts.push({ t: 'text', v: src.slice(last) });

    function inline(escaped) {
      let s = String(escaped || '');
      s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
      s = s.replace(/\*\*([^*]+)\*\*/g, '<b>$1</b>');
      s = s.replace(/\*([^*]+)\*/g, '<i>$1</i>');
      s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (full, txt, href) => {
        const h = String(href || '').replace(/&amp;/g, '&').replace(/&quot;/g, '"').trim();
        if (!/^https?:\/\//i.test(h) && !/^mailto:/i.test(h)) return full;
        const safeHref = escapeHtml(h);
        return `<a href="${safeHref}" target="_blank" rel="noopener noreferrer">${txt}</a>`;
      });
      return s;
    }

    let html = '';
    parts.forEach(p => {
      if (p.t === 'code') {
        html += `<pre><code>${escapeHtml(p.v || '').replace(/^\n+/, '')}</code></pre>`;
        return;
      }
      const blocks = String(p.v || '').split(/\n\s*\n/);
      blocks.forEach(b => {
        const lines = String(b || '').split('\n');
        if (!lines.length) return;
        const first = lines[0];
        if (/^###\s+/.test(first)) {
          html += `<h3>${inline(escapeHtml(first.replace(/^###\s+/, '')))}</h3>`;
          lines.slice(1).forEach(ln => { if (String(ln||'').trim()) html += `<p>${inline(escapeHtml(ln))}</p>`; });
          return;
        }
        if (/^##\s+/.test(first)) {
          html += `<h2>${inline(escapeHtml(first.replace(/^##\s+/, '')))}</h2>`;
          lines.slice(1).forEach(ln => { if (String(ln||'').trim()) html += `<p>${inline(escapeHtml(ln))}</p>`; });
          return;
        }
        if (/^#\s+/.test(first)) {
          html += `<h1>${inline(escapeHtml(first.replace(/^#\s+/, '')))}</h1>`;
          lines.slice(1).forEach(ln => { if (String(ln||'').trim()) html += `<p>${inline(escapeHtml(ln))}</p>`; });
          return;
        }
        const joined = lines.map(ln => inline(escapeHtml(ln))).join('<br>');
        html += `<p>${joined}</p>`;
      });
    });
    return html || '<div class="muted">(empty)</div>';
  }

  function renderMarkdownInto(cellId, raw) {
    const md = document.getElementById(`md-${cellId}`);
    if (!md) return;
    md.innerHTML = renderMarkdownSafe(raw);
    syncCellTypeDom(cellId);
  }

  function toggleCellType(cellId) {
    const doc = getActiveDoc();
    if (!doc) return;
    const cell = doc.cells.find(c => c.id === cellId);
    if (!cell) return;
    cell.type = (cell.type === 'markdown') ? 'code' : 'markdown';
    // switching to markdown means output is hidden
    syncCellTypeDom(cellId);
    if (cell.type === 'markdown') renderMarkdownInto(cellId, cell.code || '');
    markDirty(doc);
  }


  function renderCells() {
    const wrap = document.getElementById('cells');
    const doc = getActiveDoc();
    if (!wrap || !doc) return;

    wrap.innerHTML = '';
    doc.cells.forEach((c, i) => wrap.appendChild(createCellEl(c, i)));
    if (!activeCellId && doc.cells.length) activeCellId = doc.cells[0].id;
  }

  function addCellBelow(id) {
    const doc = getActiveDoc();
    if (!doc) return;
    const i = doc.cells.findIndex(c => c.id === id);
    const item = normalizeCell({});
    if (i >= 0) doc.cells.splice(i + 1, 0, item);
    else doc.cells.push(item);
    activeCellId = item.id;
    markDirty(doc);
    renderCells();
    setTimeout(() => {
      const el = document.querySelector(`.cell[data-id="${cssEsc(item.id)}"] textarea`);
      if (el) el.focus();
    }, 30);
  }

  function addCellEnd() {
    const doc = getActiveDoc();
    if (!doc) return;
    const item = normalizeCell({});
    doc.cells.push(item);
    activeCellId = item.id;
    markDirty(doc);
    renderCells();
    setTimeout(() => {
      const el = document.querySelector(`.cell[data-id="${cssEsc(item.id)}"] textarea`);
      if (el) el.focus();
    }, 30);
  }

  function deleteCell(id) {
    const doc = getActiveDoc();
    if (!doc) return;
    if (doc.cells.length <= 1) return;

    doc.cells = doc.cells.filter(c => c.id !== id);
    if (activeCellId === id) activeCellId = doc.cells[0].id;
    markDirty(doc);
    renderCells();
  }

  function deleteActiveCell() {
    const doc = getActiveDoc();
    if (!doc) return;
    if (!activeCellId) return;
    deleteCell(activeCellId);
  }

  // -----------------------------
  // Snippet picker / insert
  // -----------------------------
  function insertSnippet(code) {
    const doc = getActiveDoc();
    if (!doc) return;

    const id = activeCellId || (doc.cells[0] && doc.cells[0].id) || '';
    if (!id) return;
    const cell = doc.cells.find(c => c.id === id);
    if (!cell) return;

    const el = document.querySelector(`.cell[data-id="${cssEsc(id)}"] textarea`);
    const snippet = String(code || '');
    if (el) {
      const start = el.selectionStart || 0;
      const end = el.selectionEnd || 0;
      const before = el.value.slice(0, start);
      const after = el.value.slice(end);
      const join = (before && !before.endsWith('\n')) ? '\n' : '';
      el.value = before + join + snippet + '\n' + after;
      el.selectionStart = el.selectionEnd = (before + join + snippet + '\n').length;
      el.focus();
      cell.code = el.value;
    } else {
      cell.code = (cell.code || '') + '\n' + snippet + '\n';
    }
    markDirty(doc);
  }

  function showModal(title, bodyHtml, onConfirm) {
    const wrap = document.getElementById('nbModal');
    const t = document.getElementById('nbModalTitle');
    const b = document.getElementById('nbModalBody');
    const c = document.getElementById('nbModalConfirm');
    const x = document.getElementById('nbModalClose');

    if (!wrap || !t || !b || !c || !x) return;

    t.innerHTML = title || 'Modal';
    b.innerHTML = bodyHtml || '';
    wrap.style.display = 'flex';

    // Reset confirm button each time
    c.innerHTML = '<i class="fas fa-check"></i> Save';
    c.style.display = onConfirm ? '' : 'none';

    const close = () => {
      wrap.style.display = 'none';
      c.onclick = null;
    };
    x.onclick = close;
    wrap.onclick = (e) => { if (e.target === wrap) close(); };

    c.onclick = async (e) => {
      e.preventDefault();
      try {
        if (onConfirm) await onConfirm();
        close();
      } catch (err) {
        toast(String(err && err.message ? err.message : err));
      }
    };
  }

  function openSnippetPicker() {
    const q = `
      <div class="muted" style="margin-bottom:8px;">Search snippets and click one to insert into the active cell.</div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <input id="pickQ" class="form-control form-control-sm" placeholder="Search..." />
        <button type="button" class="btn btn-sm btn-azure-outline" id="btnPickNew"><i class="fas fa-plus"></i> New</button>
      </div>
      <div style="height:10px;"></div>
      <div id="pickList" style="display:flex; flex-direction:column; gap:10px;"></div>
    `;
    showModal('<i class="fas fa-magnifying-glass"></i> Snippets', q, null);

    const input = document.getElementById('pickQ');
    const list = document.getElementById('pickList');
    const btnNew = document.getElementById('btnPickNew');

    function renderPick() {
      if (!list) return;
      const qq = String((input || {}).value || '').trim().toLowerCase();
      const rows = snippets.filter(s => {
        const hay = `${s.name||''}\n${s.code||''}`.toLowerCase();
        return !qq || hay.includes(qq);
      });

      list.innerHTML = '';
      if (!rows.length) {
        list.innerHTML = '<div class="muted">No matches.</div>';
        return;
      }

      rows.slice(0, 50).forEach(s => {
        const div = document.createElement('div');
        div.className = 'sn-card';
        div.style.cursor = 'pointer';
        div.innerHTML = `
          <div class="top">
            <div>
              <div class="name"><i class="fas fa-wand-magic-sparkles" style="color:#1c96ca; margin-right:6px;"></i>${escapeHtml(s.name||'Snippet')}</div>
              <div class="muted" style="margin-top:4px;">${escapeHtml((s.code||'').slice(0, 140))}${(s.code||'').length>140?'â€¦':''}</div>
            </div>
            <div>
              <button type="button" class="btn btn-sm btn-azure-outline" data-act="copy"><i class="fas fa-copy"></i></button>
            </div>
          </div>
        `;
        div.addEventListener('click', (e) => {
          // ignore copy button click
          if (e && e.target && (e.target.closest && e.target.closest('button[data-act="copy"]'))) return;
          insertSnippet(s.code || '');
          toast('Inserted snippet');
        });
        div.querySelector('button[data-act="copy"]').addEventListener('click', async (e) => {
          e.preventDefault();
          await copyToClipboard(String(s.code||''));
          toast('Copied');
        });
        list.appendChild(div);
      });
    }

    if (input) input.addEventListener('input', renderPick);
    if (btnNew) btnNew.addEventListener('click', (e) => { e.preventDefault(); openSnippetModal(); });
    renderPick();
    setTimeout(() => { if (input) input.focus(); }, 50);
  }


  let _vaultCache = { stages: [], items: [] };
  let _connectorCache = null;

  async function openVaultPicker() {
    const { org, sup } = currentCtx();
    if (!org || !sup) { alert('Select a tenant first.'); return; }

    const body = `
      <div class="muted" style="margin-bottom:8px;">Search vault envs and click one to view links/keys.</div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <input id="vaultQ" class="form-control form-control-sm" placeholder="Search envs..." />
        <select id="vaultStage" class="form-control form-control-sm" style="max-width:180px;"></select>
        <button type="button" class="btn btn-sm btn-azure-outline" id="vaultRefresh"><i class="fas fa-rotate"></i></button>
      </div>
      <div style="height:10px;"></div>
      <div id="vaultList" style="display:flex; flex-direction:column; gap:10px;"></div>
    `;
    showModal('<i class="fas fa-lock"></i> Vault', body, null);

    const input = document.getElementById('vaultQ');
    const sel = document.getElementById('vaultStage');
    const list = document.getElementById('vaultList');
    const btnRef = document.getElementById('vaultRefresh');

    async function refresh() {
      try {
        const res = await getJSON(`/reflection/vault/envs/list?org=${encodeURIComponent(org)}&sup=${encodeURIComponent(sup)}`);
        if (res && res.ok) _vaultCache = { stages: res.stages || [], items: res.items || [] };
      } catch (e) {
        toast('Vault list failed');
      }
      render();
    }

    function render() {
      if (!list || !sel) return;
      const qq = String((input || {}).value || '').trim().toLowerCase();
      const stage = String((sel || {}).value || '');
      const items = Array.isArray(_vaultCache.items) ? _vaultCache.items : [];

      // stage options
      sel.innerHTML = '';
      const stages = Array.isArray(_vaultCache.stages) ? _vaultCache.stages : [];
      stages.forEach((s, i) => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s;
        sel.appendChild(opt);
        if (!stage && i === 0) sel.value = s;
      });

      const st = String((sel || {}).value || '');
      const rows = items.filter(x => {
        const hay = `${x.name||''} ${x.last_updated_by||''}`.toLowerCase();
        return (!qq || hay.includes(qq));
      }).slice(0, 50);

      list.innerHTML = '';
      if (!rows.length) {
        list.innerHTML = '<div class="muted">No matches.</div>';
        return;
      }
      rows.forEach(x => {
        const div = document.createElement('div');
        div.className = 'sn-card';
        div.style.cursor = 'pointer';
        div.innerHTML = `
          <div class="top">
            <div>
              <div class="name"><i class="fas fa-file-shield" style="color:#1c96ca; margin-right:6px;"></i>${escapeHtml(x.name||'')}</div>
              <div class="muted" style="margin-top:4px;">Last by ${escapeHtml(displayCreator(x.last_updated_by||''))}</div>
            </div>
            <div class="muted mono">${escapeHtml(st||'')}</div>
          </div>
        `;
        div.addEventListener('click', () => openVaultEnvDetail(x.name, st));
        list.appendChild(div);
      });
    }

    if (btnRef) btnRef.addEventListener('click', (e) => { e.preventDefault(); refresh(); });
    if (input) input.addEventListener('input', render);
    if (sel) sel.addEventListener('change', render);

    if (!_vaultCache.items.length) await refresh(); else render();
    setTimeout(() => { if (input) input.focus(); }, 50);
  }

  function _parseDotenvKeys(content) {
    const keys = [];
    String(content || '').split(/\r?\n/).forEach(line => {
      const s = String(line || '').trim();
      if (!s || s.startsWith('#')) return;
      const idx = s.indexOf('=');
      if (idx <= 0) return;
      const k = s.slice(0, idx).trim();
      if (k) keys.push(k);
    });
    return keys;
  }

  async function openVaultEnvDetail(name, stage) {
    const { org, sup } = currentCtx();
    if (!org || !sup) return;
    const qName = String(name||'');
    const qStage = String(stage||'');
    const res = await postJSON('/reflection/vault/envs/get', { org, sup, name: qName, stage: qStage });
    const links = (res && res.links) ? res.links : {};
    const primary = (links.primary && links.primary.url) ? links.primary.url : '';
    const secondary = (links.secondary && links.secondary.url) ? links.secondary.url : '';
    const raw = (links.raw && links.raw.url) ? links.raw.url : '';
    const keys = _parseDotenvKeys((res && res.content) ? res.content : '');
    const body = `
      <div class="muted" style="margin-bottom:8px;">Select a link to insert the Vault loader, or click a key to insert <span class="mono">vault_vars.get("KEY")</span>.</div>
      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        ${primary ? `<button type="button" class="btn btn-sm btn-azure-outline" id="vaultInsPrimary"><i class="fas fa-link"></i> Insert primary</button>` : ``}
        ${secondary ? `<button type="button" class="btn btn-sm btn-azure-outline" id="vaultInsSecondary"><i class="fas fa-link"></i> Insert secondary</button>` : ``}
        ${raw ? `<button type="button" class="btn btn-sm btn-azure-outline" id="vaultInsRaw"><i class="fas fa-link"></i> Insert raw</button>` : ``}
      </div>
      <div style="height:10px;"></div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <input id="vaultKeyQ" class="form-control form-control-sm" placeholder="Search keys..." />
      </div>
      <div style="height:10px;"></div>
      <div id="vaultKeys" style="display:flex; flex-direction:column; gap:6px; max-height:320px; overflow:auto;"></div>
    `;
    showModal('<i class="fas fa-lock"></i> Vault: ' + escapeHtml(name||''), body, null);

    const origin = window.location.origin || '';
    function ins(urlPath) {
      const full = (urlPath && urlPath.startsWith('/')) ? (origin + urlPath) : String(urlPath||'');
      const snippet = [
        'import requests',
        '',
        `url = "${full}"`,
        'vault_data = requests.get(url, timeout=30).json()',
        '',
        'vault_vars = vault_data.get("vars", {})',
        ''
      ].join('\n');
      insertSnippet(snippet);
      toast('Inserted Vault loader');
    }

    const btnP = document.getElementById('vaultInsPrimary');
    const btnS = document.getElementById('vaultInsSecondary');
    const btnR = document.getElementById('vaultInsRaw');
    if (btnP) btnP.addEventListener('click', (e) => { e.preventDefault(); ins(primary); });
    if (btnS) btnS.addEventListener('click', (e) => { e.preventDefault(); ins(secondary); });
    if (btnR) btnR.addEventListener('click', (e) => { e.preventDefault(); ins(raw); });

    const keyInput = document.getElementById('vaultKeyQ');
    const wrap = document.getElementById('vaultKeys');

    function renderKeys() {
      if (!wrap) return;
      const qq = String((keyInput||{}).value || '').trim().toLowerCase();
      const rows = keys.filter(k => !qq || String(k||'').toLowerCase().includes(qq)).slice(0, 200);
      wrap.innerHTML = '';
      if (!rows.length) {
        wrap.innerHTML = '<div class="muted">No keys.</div>';
        return;
      }
      rows.forEach(k => {
        const div = document.createElement('div');
        div.className = 'sn-card';
        div.style.cursor = 'pointer';
        div.style.padding = '8px 10px';
        div.innerHTML = `<div class="mono">${escapeHtml(k)}</div>`;
        div.addEventListener('click', () => { insertSnippet(`vault_vars.get("${String(k).replaceAll('"','\\\"')}")`); toast('Inserted key'); });
        wrap.appendChild(div);
      });
    }

    if (keyInput) keyInput.addEventListener('input', renderKeys);
    renderKeys();
    setTimeout(() => { if (keyInput) keyInput.focus(); }, 50);
  }

  async function openConnectorPicker() {
    const body = `
      <div class="muted" style="margin-bottom:8px;">Search Airbyte connectors and click one to insert an auto-mapped setup (requires <span class="mono">vault_vars</span>).</div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <input id="conQ" class="form-control form-control-sm" placeholder="Search connectors..." />
        <button type="button" class="btn btn-sm btn-azure-outline" id="conInsDiscovery"><i class="fas fa-wand-magic-sparkles"></i> Insert discovery snippet</button>
      </div>
      <div style="height:10px;"></div>
      <div id="conList" style="display:flex; flex-direction:column; gap:10px; max-height:360px; overflow:auto;"></div>
    `;
    showModal('<i class="fas fa-plug"></i> Connectors', body, null);

    const input = document.getElementById('conQ');
    const list = document.getElementById('conList');
    const btnDisc = document.getElementById('conInsDiscovery');

    if (btnDisc) btnDisc.addEventListener('click', (e) => {
      e.preventDefault();
      const snippet = [
        'import airbyte as ab',
        '',
        '# Get a list of all available source connectors',
        'sources = ab.get_available_connectors()',
        '',
        '# Print the first 10 connectors to see their names',
        'for source in sources[:10]:',
        '    print(source)',
        '',
        '# To find a specific one, like MSSQL:',
        'mssql_connectors = [s for s in sources if "mssql" in s.lower()]',
        'print(f"Found MSSQL connectors: {mssql_connectors}")',
        ''
      ].join('\n');
      insertSnippet(snippet);
      toast('Inserted discovery snippet');
    });

    async function ensureList() {
      if (_connectorCache) return _connectorCache;
      const res = await getJSON('/reflection/studio/connectors');
      _connectorCache = (res && res.ok && Array.isArray(res.items)) ? res.items : [];
      return _connectorCache;
    }

    function buildConnectorSnippet(connectorName) {
      const cn = String(connectorName || '').trim();
      const snippet = [
        'import airbyte as ab',
        '',
        '# Requires `vault_vars` from the Vault loader (see Vault button).',
        `connector_name = "${cn}"`,
        '',
        '# Fetch the connector config schema (JSON Schema) and auto-map required keys from vault_vars.',
        'spec = ab.get_source(connector_name, config=None, no_executor=True).config_spec',
        'required = list(spec.get("required", []) or [])',
        'properties = dict(spec.get("properties", {}) or {})',
        '',
        'def _norm_key(s: str) -> str:',
        '    return "".join(ch.lower() for ch in str(s or "") if ch.isalnum())',
        '',
        'def _score(cfg_key: str, prop: dict, vault_key: str) -> int:',
        '    # strictly derived from the connector spec key/title/description (no hardcoded mappings)',
        '    vk = _norm_key(vault_key)',
        '    hint = " ".join([str(cfg_key or ""), str(prop.get("title") or ""), str(prop.get("description") or "")]).lower()',
        '    best = 0',
        '',
        '    ck = _norm_key(cfg_key)',
        '    if ck and (ck in vk or vk in ck):',
        '        best = max(best, 50)',
        '',
        '    for tok in [t for t in re.split(r"[^a-z0-9]+", hint) if t]:',
        '        if tok and tok in vk:',
        '            best = max(best, 60)',
        '',
        '    best = max(best, len(set(_norm_key(hint)) & set(vk)))',
        '    return best',
        '',
        'import re',
        '',
        'vault_keys = list(vault_vars.keys())',
        'auto_mapping = {}  # Vault Key -> Airbyte Config Key',
        'for cfg_key in required:',
        '    prop = properties.get(cfg_key, {}) if isinstance(properties, dict) else {}',
        '    best_key = None',
        '    best_score = -1',
        '    for vk in vault_keys:',
        '        sc = _score(cfg_key, prop if isinstance(prop, dict) else {}, vk)',
        '        if sc > best_score:',
        '            best_score = sc',
        '            best_key = vk',
        '    if best_key and best_score >= 10:',
        '        auto_mapping[best_key] = cfg_key',
        '',
        'source_config = {cfg_key: vault_vars.get(vault_key) for vault_key, cfg_key in auto_mapping.items()}',
        '',
        '# Apply schema defaults where available',
        'for k, p in properties.items():',
        '    if k not in source_config and isinstance(p, dict) and "default" in p:',
        '        source_config[k] = p["default"]',
        '',
        'missing = [k for k in required if k not in source_config]',
        'if missing:',
        '    print(f"Missing required config keys (not found in vault_vars): {missing}")',
        '',
        '# Initialize the source',
        'source = ab.get_source(connector_name, config=source_config)',
        ''
      ].join('\n');
      return snippet;
    }

    async function render() {
      if (!list) return;
      const items = await ensureList();
      const qq = String((input||{}).value || '').trim().toLowerCase();
      const rows = items.filter(x => !qq || String(x||'').toLowerCase().includes(qq)).slice(0, 80);
      list.innerHTML = '';
      if (!rows.length) {
        list.innerHTML = '<div class="muted">No matches.</div>';
        return;
      }
      rows.forEach(name => {
        const div = document.createElement('div');
        div.className = 'sn-card';
        div.style.cursor = 'pointer';
        div.innerHTML = `<div class="top"><div class="name"><i class="fas fa-plug" style="color:#1c96ca; margin-right:6px;"></i>${escapeHtml(name)}</div></div>`;
        div.addEventListener('click', () => { insertSnippet(buildConnectorSnippet(name)); toast('Inserted connector'); });
        list.appendChild(div);
      });
    }

    if (input) input.addEventListener('input', render);
    await render();
    setTimeout(() => { if (input) input.focus(); }, 50);
  }


  async function copyToClipboard(text) {
    const t = String(text || '');
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(t);
        return true;
      }
    } catch (e) {}
    const ta = document.createElement('textarea');
    ta.value = t;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    try { document.execCommand('copy'); } catch (e) {}
    document.body.removeChild(ta);
    return true;
  }

  // -----------------------------
  // Snippets CRUD
  // -----------------------------
  function renderSnippets() {
    const grid = document.getElementById('snGrid');
    const empty = document.getElementById('snEmpty');
    if (!grid) return;

    const q = String((document.getElementById('snSearch') || {}).value || '').trim().toLowerCase();
    const rows = snippets.filter(s => {
      const hay = `${s.name||''}\n${s.code||''}`.toLowerCase();
      return !q || hay.includes(q);
    });

    grid.innerHTML = '';
    rows.forEach(s => {
      const card = document.createElement('div');
      card.className = 'sn-card';
      card.innerHTML = `
        <div class="top">
          <div>
            <div class="name">${escapeHtml(s.name || 'Snippet')}</div>
            <div class="muted" style="margin-top:4px;">updated: ${escapeHtml(fmt(s.updated_at || s.created_at))}</div>
          </div>
        </div>
        <pre class="mono">${escapeHtml((s.code || '').slice(0, 900))}${(s.code||'').length>900 ? '\nâ€¦' : ''}</pre>
        <div class="sn-actions">
          <button type="button" class="btn btn-sm btn-azure-outline" data-act="copy"><i class="fas fa-copy"></i> Copy</button>
          <button type="button" class="btn btn-sm btn-azure-outline" data-act="edit"><i class="fas fa-pen"></i> Edit</button>
          <button type="button" class="btn btn-sm btn-danger-outline" data-act="del"><i class="fas fa-trash"></i> Delete</button>
        </div>
      `;
      card.querySelector('button[data-act="copy"]').addEventListener('click', async () => {
        await copyToClipboard(String(s.code || ''));
        toast('Copied');
      });
      card.querySelector('button[data-act="edit"]').addEventListener('click', () => openSnippetModal(s));
      card.querySelector('button[data-act="del"]').addEventListener('click', () => deleteSnippet(s.id));
      grid.appendChild(card);
    });

    if (empty) empty.style.display = rows.length ? 'none' : '';
  }

  function deleteSnippet(id) {
    if (!confirm('Delete this snippet?')) return;
    snippets = snippets.filter(s => s.id !== id);
    saveSnippets(snippets);
    renderSnippets();
    toast('Snippet deleted');
  }

  function openSnippetModal(existing) {
    const s = existing || null;
    const title = s ? '<i class="fas fa-pen"></i> Edit snippet' : '<i class="fas fa-plus"></i> New snippet';
    const body = `
      <div class="form-group" style="margin-bottom:10px;">
        <label class="muted" style="font-size:12px;">Name</label>
        <input id="snName" class="form-control form-control-sm" value="${escapeHtml(s ? (s.name||'') : '')}" placeholder="My snippet" />
      </div>
      <div class="form-group" style="margin-bottom:10px;">
        <label class="muted" style="font-size:12px;">Code</label>
        <textarea id="snCode" class="form-control form-control-sm mono" rows="12" placeholder="print('hello')">${escapeHtml(s ? (s.code||'') : '')}</textarea>
      </div>
    `;
    showModal(title, body, async () => {
      const name = String((document.getElementById('snName')||{}).value || '').trim();
      const code = String((document.getElementById('snCode')||{}).value || '').trim();
      if (!name) throw new Error('Name is required');
      if (!code) throw new Error('Code is required');

      if (s) {
        s.name = name;
        s.code = code;
        s.updated_at = nowISO();
        snippets = snippets.map(x => x.id === s.id ? s : x);
      } else {
        snippets.unshift({ id: genId('sn'), name, code, created_at: nowISO(), updated_at: nowISO() });
      }
      saveSnippets(snippets);
      renderSnippets();
      toast('Snippet saved');
    });
  }

  // -----------------------------
  // Save notebook
  // -----------------------------
  function markDirty(doc) {
    doc.dirty = true;
    doc.updated_at = nowISO();
    renderOpenTabs();
  }

  function saveActiveNotebook() {
    const { userHash } = currentCtx();
    const doc = getActiveDoc();
    if (!doc) return;

    const nameVal = String((document.getElementById('nbEditorName')||{}).value || '').trim() || 'Untitled';
    doc.name = nameVal;

    if (!doc.notebook_id) {
      // first save: create a new notebook entry
      const id = genId('nb');
      const nb = {
        id,
        name: doc.name,
        creator: userName || userHash || doc.creator || '',
        created_at: doc.created_at || nowISO(),
        updated_at: nowISO(),
        cells: doc.cells.map(c => ({ id: c.id, type: c.type || 'code', code: c.code, output: c.output || null })),
      };
      notebooks.unshift(nb);
      saveNotebooks(notebooks);

      doc.notebook_id = id;
      doc.creator = nb.creator;
      doc.created_at = nb.created_at;
      doc.updated_at = nb.updated_at;
      doc.dirty = false;

      renderNotebookList();
      activateEditorTab(doc.tab_id);
      toast('Studio saved');
      return;
    }

    // update existing
    notebooks = notebooks.map(n => {
      if (n.id !== doc.notebook_id) return n;
      return {
        ...n,
        name: doc.name,
        updated_at: nowISO(),
        cells: doc.cells.map(c => ({ id: c.id, type: c.type || 'code', code: c.code, output: c.output || null })),
      };
    });
    saveNotebooks(notebooks);

    doc.dirty = false;
    doc.updated_at = nowISO();
    renderNotebookList();
    renderOpenTabs();
    toast('Studio updated');
  }

  function _toSourceLines(txt) {
    const s = String(txt || '');
    if (!s) return [];
    // Jupyter uses a list of strings; preserve newlines.
    return s.split(/\n/).map((line, i, arr) => (i < arr.length - 1 ? line + '\n' : line));
  }

  function buildIpynbPayload(nbLike) {
    const cells = (nbLike && Array.isArray(nbLike.cells)) ? nbLike.cells : [];
    const ipCells = [];
    cells.forEach(c => {
      const typ = (c && c.type === 'markdown') ? 'markdown' : 'code';
      if (typ === 'markdown') {
        ipCells.push({
          cell_type: 'markdown',
          metadata: {},
          source: _toSourceLines(c.code || ''),
        });
        return;
      }
      const outs = [];
      const out = c && c.output ? c.output : null;
      if (out && (String(out.stdout||'').trim() || String(out.stderr||'').trim())) {
        if (String(out.stdout||'')) outs.push({ output_type: 'stream', name: 'stdout', text: _toSourceLines(out.stdout) });
        if (String(out.stderr||'')) outs.push({ output_type: 'stream', name: 'stderr', text: _toSourceLines(out.stderr) });
      }
      ipCells.push({
        cell_type: 'code',
        metadata: {},
        execution_count: null,
        source: _toSourceLines(c.code || ''),
        outputs: outs,
      });
    });
    return {
      cells: ipCells,
      metadata: {
        kernelspec: { display_name: 'Python 3', language: 'python', name: 'python3' },
        language_info: { name: 'python' },
      },
      nbformat: 4,
      nbformat_minor: 5,
    };
  }

  function downloadNotebookIpynb(nbLike) {
    const name = String((nbLike && nbLike.name) ? nbLike.name : 'notebook').trim() || 'notebook';
    const safe = name.replace(/[^a-z0-9\-_. ]/gi, '_').slice(0, 60).trim() || 'notebook';
    const payload = buildIpynbPayload(nbLike);
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/x-ipynb+json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${safe}.ipynb`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => { try { URL.revokeObjectURL(url); } catch (e) {} }, 500);
  }



  // -----------------------------
  // Run cells
  // -----------------------------
  function setOutput(cellId, ok, stdout, stderr, meta, persist = true) {
    const o = String(stdout || '');
    const e = String(stderr || '');
    const mm = meta ? String(meta) : '';
    const has = (o.trim() || e.trim() || mm.trim());

    if (persist) {
      const doc = getActiveDoc();
      if (doc) {
        const cell = doc.cells.find(c => c.id === cellId);
        if (cell && cell.type !== 'markdown') {
          cell.output = has ? { ok: !!ok, stdout: o, stderr: e, meta: mm } : null;
          markDirty(doc);
        }
      }
    }

    const box = document.getElementById(`out-${cellId}`);
    if (!box) return;

    box.style.display = has ? 'block' : 'none';
    box.className = 'output mono ' + (ok ? 'ok' : 'err');
    box.innerHTML = `
      ${mm ? `<div class="muted" style="margin-bottom:8px;">${escapeHtml(mm)}</div>` : ``}
      ${o ? `<div><div class="muted" style="margin-bottom:4px;">stdout</div><div class="cell-console" style="white-space:pre-wrap; overflow-wrap:anywhere;">${escapeHtmlNl(o)}</div></div>` : ``}
      ${e ? `<div style="margin-top:10px;"><div class="muted" style="margin-bottom:4px;">stderr</div><div class="cell-console" style="white-space:pre-wrap; overflow-wrap:anywhere;">${escapeHtmlNl(e)}</div></div>` : ``}
    `;
    syncCellTypeDom(cellId);
  }

  function setStatus(cellId, txt) {
    const el = document.getElementById(`status-${cellId}`);
    if (el) el.textContent = txt || '';
  }

  function stopAllRuns() {
    stopRequested = true;
    activeControllers.forEach(c => { try { c.abort(); } catch (e) {} });
    activeControllers = [];

    // Ask server-side notebook kernels to reset before closing sockets
    try {
      Object.keys(notebookWsSessions || {}).forEach(tid => {
        const sess = notebookWsSessions[tid];
        try {
          if (sess && sess.sock && sess.sock.readyState === WebSocket.OPEN && sess.sessionId) {
            sess.sock.send(JSON.stringify({ op: 'reset', session_id: String(sess.sessionId) }));
          }
        } catch (e) {}
      });
    } catch (e) {}

    // Properly reset stateful notebook sessions (closes sockets and clears map)
    try { closeAllNotebookWsSessions('stop'); } catch (e) {}

    // Close any remaining sockets (safety net)
    activeSockets.forEach(s => { try { s.close(); } catch (e) {} });
    activeSockets = [];

    toast('Stopped (client-side)');
    // allow new runs
    setTimeout(() => { stopRequested = false; }, 200);
  }


  function normalizeNotebookWsUrl(raw) {
    const s = String(raw || '').trim();
    if (!s) return '';
    let u = s;

    // Convert http(s) to ws(s) for convenience.
    u = u.replace(/^http:/i, 'ws:').replace(/^https:/i, 'wss:');

    // If user saved "host:port/path", prefix with current ws scheme.
    if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(u)) {
      const proto = (location.protocol === 'https:') ? 'wss://' : 'ws://';
      u = proto + u.replace(/^\/+/, '');
    }

    try {
      const url = new URL(u);

      // "0.0.0.0" is not a routable browser hostname; map it to a usable host.
      if (url.hostname === '0.0.0.0') {
        const h = String(location.hostname || 'localhost');
        url.hostname = (h && h !== '0.0.0.0') ? h : 'localhost';
      }

      // Mirror index.html behavior: if Studio is served over HTTPS, use wss:// (CSP typically blocks ws://).
      if (location.protocol === 'https:' && String(url.protocol || '').toLowerCase() === 'ws:') {
        url.protocol = 'wss:';
      }

      // Match the simple notebook runner (index.html): if no path is provided, default to /ws/execute.
      const p = String(url.pathname || '');
      if (!p || p === '/') url.pathname = '/ws/execute';

      return url.toString();
    } catch (e) {
      return u;
    }
  }


function streamOutputInit(cellId, meta) {
    const doc = getActiveDoc();
    if (doc) {
      const cell = doc.cells.find(c => c.id === cellId);
      if (cell && cell.type !== 'markdown') {
        cell.output = { ok: true, stdout: '', stderr: '', meta: String(meta || '') };
        markDirty(doc);
      }
    }

    const box = document.getElementById(`out-${cellId}`);
    if (!box) return;
    box.style.display = 'block';
    box.className = 'output mono ok';
    box.innerHTML = `
      ${meta ? `<div class="muted" style="margin-bottom:8px;">${escapeHtml(String(meta))}</div>` : ``}
      <div>
        <div class="muted" style="margin-bottom:4px;">stdout</div>
        <div id="console-${cellId}" style="white-space:pre-wrap; overflow-wrap:anywhere;"></div>
      </div>
    `;
  }

  function streamOutputAppend(cellId, chunk) {
    const t = String(chunk || '');
    const consoleDiv = document.getElementById(`console-${cellId}`);
    if (consoleDiv) {
      // Match index.html: append spans for each streamed chunk.
      const span = document.createElement('span');
      if (t.includes('Progress')) span.className = 'progress-line';
      span.innerText = t;
      consoleDiv.appendChild(span);

      const box = document.getElementById(`out-${cellId}`);
      if (box) box.scrollTop = box.scrollHeight;
    }

    const doc = getActiveDoc();
    if (doc) {
      const cell = doc.cells.find(c => c.id === cellId);
      if (cell && cell.output && cell.type !== 'markdown') {
        cell.output.stdout = String(cell.output.stdout || '') + t;
        markDirty(doc);
      }
    }
  }

  // -----------------------------
  // Notebook WebSocket execution (index.html-style)
  // -----------------------------
  function closeNotebookWsSession(tabId, reason) {
    const tid = String(tabId || '').trim();
    if (!tid) return;
    const sess = notebookWsSessions[tid];
    if (!sess) return;
    try {
      if (sess && sess.sock && sess.sock.readyState === WebSocket.OPEN && sess.sessionId) {
        sess.sock.send(JSON.stringify({ op: 'reset', session_id: String(sess.sessionId) }));
      }
    } catch (e) {}
    try { if (sess.sock) sess.sock.close(); } catch (e) {}
    if (sess.sock) activeSockets = activeSockets.filter(s => s !== sess.sock);
    delete notebookWsSessions[tid];
  }

  function closeAllNotebookWsSessions(reason) {
    Object.keys(notebookWsSessions || {}).forEach(tid => closeNotebookWsSession(tid, reason));
  }

  async function getOrCreateNotebookWsSession(tabId, pool) {
    const tid = String(tabId || '').trim();
    if (!tid) throw new Error('Missing notebook tab');

    const wsUrl = normalizeNotebookWsUrl(pool && pool.ws_url ? pool.ws_url : '');
    if (!wsUrl) throw new Error('Selected compute has no ws_url');

    const profile = (pool && pool.has_internet) ? 'internet' : 'no-internet';

    let sess = notebookWsSessions[tid] || null;
    const cmpWs = (u) => String(u || '').replace(/^wss:/i, 'ws:');
    if (sess && (cmpWs(sess.wsUrl) !== cmpWs(wsUrl) || sess.profile !== profile)) {
      closeNotebookWsSession(tid, 'compute/profile changed');
      sess = null;
    }

    if (sess && sess.sock && sess.sock.readyState === WebSocket.OPEN) return sess;
    if (sess && sess.sock && sess.sock.readyState === WebSocket.CONNECTING && sess.openPromise) {
      await sess.openPromise;
      return sess;
    }

    let wsUrlUsed = wsUrl;
    let sock = null;

    try {
      sock = new WebSocket(wsUrlUsed);
    } catch (e) {
      // Some deployments ship a stricter CSP (e.g. connect-src 'self' https:) which blocks ws://.
      // In that case, retry with wss://.
      const name = String(e && e.name ? e.name : '');
      const msg = String(e && e.message ? e.message : e);
      const looksCsp = (name === 'SecurityError') || /content security policy|connect-src/i.test(msg);
      const alt = wsUrlUsed.replace(/^ws:/i, 'wss:');
      if (looksCsp && alt !== wsUrlUsed) {
        try {
          sock = new WebSocket(alt);
          wsUrlUsed = alt;
        } catch (e2) {
          const msg2 = String(e2 && e2.message ? e2.message : e2);
          throw new Error(`WebSocket blocked by CSP (ws:// not allowed) and wss:// retry failed: ${msg2}`);
        }
      } else {
        throw new Error(`Failed to create WebSocket: ${msg}`);
      }
    }

    sess = { wsUrl: wsUrlUsed, profile, sock, busy: false, openPromise: null };
    notebookWsSessions[tid] = sess;
    activeSockets.push(sock);

    sess.openPromise = new Promise((resolve, reject) => {
      const timeoutMs = 15000;
      const timer = setTimeout(() => {
        try { sock.close(); } catch (e) {}
        reject(new Error('Notebook connection timeout'));
      }, timeoutMs);

      const onOpen = () => {
        clearTimeout(timer);
        resolve(true);
      };
      const onError = () => {
        clearTimeout(timer);
        reject(new Error('WebSocket error (check DevTools Console)'));
      };
      const onClose = () => {
        clearTimeout(timer);
        reject(new Error('Notebook connection closed'));
      };

      sock.addEventListener('open', onOpen, { once: true });
      sock.addEventListener('error', onError, { once: true });
      sock.addEventListener('close', onClose, { once: true });
    });

    try {
      await sess.openPromise;
      sess.openPromise = null;
      return sess;
    } catch (e) {
      closeNotebookWsSession(tid, 'connect failed');
      throw e;
    }
  }

  async function runCellOnNotebookWs(cellId, code, pool, startTs, tabIdOverride, sessionId) {
    const tid = String(tabIdOverride || activeTabId || '').trim();
    const sess = await getOrCreateNotebookWsSession(tid, pool);

    if (sess.busy) throw new Error('Notebook is busy (another cell is running)');
    sess.busy = true;
    sess.sessionId = String(sessionId || '');

    const wsUrl = String(sess.wsUrl || '');
    const profile = String(sess.profile || 'no-internet');
    const poolMeta = pool ? `Compute: ${computePoolLabel(pool)}` : '';
    const metaBase = `${poolMeta}${poolMeta ? ' â€¢ ' : ''}Notebook: ${profile} â€¢ ${wsUrl}`;

    return await new Promise((resolve) => {
      let done = false;
      let started = false;
      let stdout = '';
      let stderr = '';

      const sock = sess.sock;

      let onMessage = null;
      let onError = null;
      let onClose = null;

      const cleanup = () => {
        sess.busy = false;
        if (onMessage) { try { sock.removeEventListener('message', onMessage); } catch (e) {} }
        if (onError) { try { sock.removeEventListener('error', onError); } catch (e) {} }
        if (onClose) { try { sock.removeEventListener('close', onClose); } catch (e) {} }
      };

      const finish = (ok, errMsg) => {
        if (done) return;
        done = true;
        cleanup();

        const baseMeta = `Client: ${(performance.now()-startTs).toFixed(1)} ms`;
        const meta = `${poolMeta}${poolMeta ? ' â€¢ ' : ''}Notebook: ${profile} â€¢ ${baseMeta}`;

        if (ok) {
          setStatus(cellId, 'done');
          setOutput(cellId, true, stdout, stderr, meta);
          resolve(true);
          return;
        }

        const m = String(errMsg || 'Execution failed');
        setStatus(cellId, (m.toLowerCase().includes('stopped') ? 'stopped' : 'error'));
        setOutput(cellId, false, stdout, (stderr || m), meta);

        // If the connection is unhealthy, drop the session so the next run reconnects.
        if (sess && sess.sock && sess.sock.readyState !== WebSocket.OPEN) {
          closeNotebookWsSession(tid, 'socket unhealthy');
        }
        resolve(false);
      };

      onMessage = (event) => {
        if (stopRequested) { finish(false, 'Stopped (client-side)'); return; }
        let msg = null;
        try { msg = JSON.parse(event.data); } catch (e) { msg = null; }
        const st = msg && msg.status ? String(msg.status) : '';
        if (st === 'start') {
          started = true;
          stdout = '';
          stderr = '';
          streamOutputInit(cellId, metaBase);
          return;
        }
        if (st === 'output') {
          const chunk = msg && msg.data !== undefined ? msg.data : '';
          stdout += String(chunk || '');
          streamOutputAppend(cellId, chunk);
          return;
        }
        if (st === 'stderr') {
          const chunk = msg && msg.data !== undefined ? msg.data : '';
          stderr += String(chunk || '');
          streamOutputAppend(cellId, chunk);
          return;
        }
        if (st === 'error') {
          const em = (msg && (msg.error || msg.data)) ? (msg.error || msg.data) : 'Execution failed';
          finish(false, String(em || 'Execution failed'));
          return;
        }
        if (st === 'complete') {
          finish(true, '');
          return;
        }
      };

      onError = () => {
        if (!started) finish(false, 'WebSocket error (check DevTools Console)');
        else finish(false, 'Notebook disconnected (WebSocket error)');
      };

      onClose = () => {
        if (done) return;
        if (stopRequested) { finish(false, 'Stopped (client-side)'); return; }
        finish(false, 'Notebook connection closed');
      };

      sock.addEventListener('message', onMessage);
      sock.addEventListener('error', onError);
      sock.addEventListener('close', onClose);

      // Prepare streaming output area and send code (like index.html)
      streamOutputInit(cellId, metaBase);
      setStatus(cellId, 'runningâ€¦');
      try {
        sock.send(JSON.stringify({ code: String(code || ''), profile, session_id: String(sessionId || '') }));
      } catch (e) {
        finish(false, 'Failed to send code to notebook');
      }
    });
  }

  // Legacy one-shot runner (kept for backward compatibility)
  async function runCellOnNotebookWsOneShot(cellId, code, pool, startTs) {
    const wsUrl = normalizeNotebookWsUrl(pool && pool.ws_url ? pool.ws_url : '');
    if (!wsUrl) throw new Error('Selected compute has no ws_url');

    const profile = (pool && pool.has_internet) ? 'internet' : 'no-internet';
    const poolMeta = pool ? `Compute: ${computePoolLabel(pool)}` : '';
    const metaBase = `${poolMeta}${poolMeta ? ' â€¢ ' : ''}Notebook: ${profile} â€¢ ${wsUrl}`;

    return await new Promise((resolve, reject) => {
      let done = false;
      let started = false;
      let stdout = '';

      const sock = new WebSocket(wsUrl);
      activeSockets.push(sock);

      const finish = (ok, errMsg) => {
        if (done) return;
        done = true;
        try { sock.close(); } catch (e) {}
        activeSockets = activeSockets.filter(s => s !== sock);

        const baseMeta = `Client: ${(performance.now()-startTs).toFixed(1)} ms`;
        const meta = `${poolMeta}${poolMeta ? ' â€¢ ' : ''}Notebook: ${profile} â€¢ ${baseMeta}`;

        if (ok) {
          setStatus(cellId, 'done');
          setOutput(cellId, true, stdout, '', meta);
          resolve(true);
        } else {
          const m = String(errMsg || 'Execution failed');
          setStatus(cellId, (m.toLowerCase().includes('stopped') ? 'stopped' : 'error'));
          setOutput(cellId, false, stdout, m, meta);
          resolve(false);
        }
      };

      sock.onopen = () => {
        if (stopRequested) { finish(false, 'Stopped (client-side)'); return; }
        // Prepare streaming output area
        streamOutputInit(cellId, metaBase);
        setStatus(cellId, 'runningâ€¦');
        try {
          sock.send(JSON.stringify({ code: String(code || ''), profile, session_id: String(sessionId || '') }));
        } catch (e) {
          finish(false, 'Failed to send code to notebook');
        }
      };

      sock.onmessage = (event) => {
        if (stopRequested) { finish(false, 'Stopped (client-side)'); return; }
        let msg = null;
        try { msg = JSON.parse(event.data); } catch (e) { msg = null; }
        const st = msg && msg.status ? String(msg.status) : '';
        if (st === 'start') {
          started = true;
          stdout = '';
          streamOutputInit(cellId, metaBase);
          return;
        }
        if (st === 'output') {
          const chunk = msg && msg.data !== undefined ? msg.data : '';
          stdout += String(chunk || '');
          streamOutputAppend(cellId, chunk);
          return;
        }
        if (st === 'complete') {
          finish(true, '');
        }
      };

      sock.onerror = () => {
        if (!started) finish(false, 'WebSocket error (check DevTools Console)');
        else finish(false, 'Notebook disconnected (WebSocket error)');
      };

      sock.onclose = () => {
        if (done) return;
        if (stopRequested) { finish(false, 'Stopped (client-side)'); return; }
        finish(false, 'Notebook connection closed');
      };
    });
  }

  function isLikelyCspWebSocketBlock(err) {
    const name = String(err && err.name ? err.name : '');
    const msg = String((err && err.message) ? err.message : (err || ''));
    return (name === 'SecurityError') || /content security policy|connect-src/i.test(msg);
  }


  async function runCell(cellId) {
    const { org, sup, userHash } = currentCtx();
    if (!org || !sup) { alert('Select a tenant first.'); return; }
    if (!userHash) { alert('Missing user hash (session). Please re-login.'); return; }

    const doc = getActiveDoc();
    if (!doc) return;
    const cell = doc.cells.find(c => c.id === cellId);
    if (!cell) return;

    if (cell.type === 'markdown') {
      renderMarkdownInto(cellId, cell.code || '');
      setStatus(cellId, 'rendered');
      return;
    }

    const code = String(cell.code || '').trim();
    if (!code) return;

    const controller = new AbortController();
    activeControllers.push(controller);

    const sessionScope = doc.notebook_id || doc.tab_id;
    const sessionId = getOrCreateKernelSessionId(sessionScope);

    const start = performance.now();
    setStatus(cellId, 'runningâ€¦');
    setOutput(cellId, true, '', '', '');

    const metaTick = setInterval(() => {
      const ms = performance.now() - start;
      setStatus(cellId, `running â€¢ ${(ms/1000).toFixed(3)}s`);
    }, 60);

    try {
      if (stopRequested) return;

      if (!computePools.length) { try { await loadComputePools(); } catch (e) {} }
      const computeId = String(selectedComputePoolId || '').trim();

      const pool = getSelectedComputePool();
      const allowLocalFallback = (new URLSearchParams(location.search)).get('local_fallback') === '1';

      const wsRaw = pool && pool.ws_url ? String(pool.ws_url) : '';
      if (pool && wsRaw && wsRaw.trim()) {
        try {
          const ok = await runCellOnNotebookWs(cellId, code, pool, start, doc.tab_id, sessionId);
          // Avoid double-execution: only fall back if the websocket was blocked before the run started.
          if (ok) return;
          return;
        } catch (e) {
          if (isLikelyCspWebSocketBlock(e)) {
            toast('WebSocket blocked by CSP; falling back to server runner');
            // fall through to the server job runner below
          } else {
            throw e;
          }
        }
      }
      if (pool && !allowLocalFallback) {
        throw new Error('Selected compute has no ws_url');
      }

      const created = await postJSON('/reflection/studio/jobs', {
        org, sup, user_hash: userHash,
        code,
        session_id: sessionId,
        compute_pool_id: computeId,
      }, controller.signal);

      const jobId = created && created.job_id ? String(created.job_id) : '';
      if (!jobId) throw new Error('Missing job_id');

      while (true) {
        if (stopRequested) return;
        const js = await getJSON(`/reflection/studio/jobs/${enc(jobId)}`, controller.signal);
        const job = js && js.job ? js.job : null;
        if (!job) throw new Error('Job not found');
        const st = String(job.status || '');
        if (st === 'queued' || st === 'running') {
          await new Promise(r => setTimeout(r, 250));
          continue;
        }

        const dur = (job.duration_ms !== undefined && job.duration_ms !== null) ? Number(job.duration_ms) : null;
        const baseMeta = (dur !== null && Number.isFinite(dur))
          ? `Server: ${dur.toFixed(3)} ms â€¢ Client: ${(performance.now()-start).toFixed(1)} ms`
          : `Client: ${(performance.now()-start).toFixed(1)} ms`;

        const pool = getSelectedComputePool();
        const poolMeta = pool ? `Compute: ${computePoolLabel(pool)}` : '';
        const meta = poolMeta ? (poolMeta + ' â€¢ ' + baseMeta) : baseMeta;

        if (st === 'done') {
          setStatus(cellId, 'done');
          setOutput(cellId, true, job.stdout || '', job.stderr || '', meta);
          break;
        }
        if (st === 'error') {
          setStatus(cellId, 'error');
          const msg = job.error ? String(job.error) : 'Execution failed';
          const stderr = (job.stderr ? String(job.stderr) : '');
          setOutput(cellId, false, job.stdout || '', stderr || msg, meta);
          break;
        }
        setStatus(cellId, st);
        break;
      }
    } catch (e) {
      if (String(e && e.name) === 'AbortError') {
        setStatus(cellId, 'stopped');
        setOutput(cellId, false, '', 'Stopped (client-side)', '');
      } else {
        setStatus(cellId, 'error');
        setOutput(cellId, false, '', String(e && e.message ? e.message : e), '');
      }
    } finally {
      clearInterval(metaTick);
      activeControllers = activeControllers.filter(x => x !== controller);
    }
  }

  async function runActiveCell() {
    const doc = getActiveDoc();
    if (!doc) return;
    const id = activeCellId || (doc.cells[0] && doc.cells[0].id) || '';
    if (!id) return;
    await runCell(id);
  }

  async function runAll() {
    const doc = getActiveDoc();
    if (!doc) return;
    for (const c of doc.cells) {
      if (stopRequested) return;
      const code = String(c.code || '').trim();
      if (code) await runCell(c.id);
    }
  }

  // -----------------------------
  // Wire UI
  // -----------------------------
  function wireBaseTabs() {
    document.querySelectorAll('#tab-navigation .tab[data-pane]').forEach(t => {
      t.addEventListener('click', () => {
        const p = t.getAttribute('data-pane');
        if (!p) return;
        setPane(p);
      });
    });

    const btnNew = document.getElementById('btnNewNotebook');
    if (btnNew) btnNew.addEventListener('click', createNewNotebookTab);

    const btnRefresh = document.getElementById('btnRefreshList');
    if (btnRefresh) btnRefresh.addEventListener('click', () => { notebooks = loadNotebooks(); renderNotebookList(); });

    const nbSearch = document.getElementById('nbSearch');
    if (nbSearch) nbSearch.addEventListener('input', renderNotebookList);

    const snSearch = document.getElementById('snSearch');
    if (snSearch) snSearch.addEventListener('input', renderSnippets);

    const btnNewSnippet = document.getElementById('btnNewSnippet');
    if (btnNewSnippet) btnNewSnippet.addEventListener('click', () => openSnippetModal(null));

    const btnAddCellTop = document.getElementById('btnAddCellTop');
    if (btnAddCellTop) btnAddCellTop.addEventListener('click', addCellEnd);

    const btnDelActive = document.getElementById('btnDeleteActiveCell');
    if (btnDelActive) btnDelActive.addEventListener('click', deleteActiveCell);

    const btnPick = document.getElementById('btnSnippetPicker');
    if (btnPick) btnPick.addEventListener('click', openSnippetPicker);

    const btnVault = document.getElementById('btnVaultPicker');
    if (btnVault) btnVault.addEventListener('click', openVaultPicker);

    const btnConn = document.getElementById('btnConnectorPicker');
    if (btnConn) btnConn.addEventListener('click', openConnectorPicker);

    const computeSel = document.getElementById('computeSelect');
    if (computeSel) computeSel.addEventListener('change', () => selectComputePool(computeSel.value));

    const btnRefreshCompute = document.getElementById('btnRefreshCompute');
    if (btnRefreshCompute) btnRefreshCompute.addEventListener('click', () => {
      loadComputePools().then(() => {
        toast((computePools && computePools.length) ? 'Compute refreshed' : 'No compute pools');
      }).catch((e) => {
        toast(String(e && e.message ? e.message : e));
      });
    });

    const btnRunA = document.getElementById('btnRunActive');
    if (btnRunA) btnRunA.addEventListener('click', runActiveCell);

    const btnRunAll = document.getElementById('btnRunAll');
    if (btnRunAll) btnRunAll.addEventListener('click', runAll);

    const btnStop = document.getElementById('btnStop');
    if (btnStop) btnStop.addEventListener('click', stopAllRuns);

    const btnSave = document.getElementById('btnSaveNotebook');
    if (btnSave) btnSave.addEventListener('click', saveActiveNotebook);

    const btnDl = document.getElementById('btnDownloadNotebook');
    if (btnDl) btnDl.addEventListener('click', () => {
      const doc = getActiveDoc();
      if (doc) downloadNotebookIpynb(doc);
    });

    const btnClose = document.getElementById('btnCloseTab');
    if (btnClose) btnClose.addEventListener('click', () => closeEditorTab(activeTabId));

    const nameInput = document.getElementById('nbEditorName');
    if (nameInput) {
      nameInput.addEventListener('input', () => {
        const doc = getActiveDoc();
        if (!doc) return;
        doc.name = String(nameInput.value || '');
        markDirty(doc);
      });
    }
  }

  // Tenant change: redirect and keep on notebooks page
  window.addEventListener("supertable-changed", function(e) {
    const detail = (e && e.detail) ? e.detail : {};
    const org = detail.org || "";
    const sup = detail.sup || "";
    const u = new URL(window.location.href);
    u.pathname = "/reflection/studio";
    u.searchParams.set("org", org);
    u.searchParams.set("sup", sup);
    window.location.href = u.toString();
  });

  // Init
  notebooks = loadNotebooks();
  snippets = loadSnippets();

  wireBaseTabs();
  loadComputePools().catch(() => {});
  renderOpenTabs();
  renderNotebookList();
  renderSnippets();
  setPane('list');

})();
</script>
{% endblock %}
